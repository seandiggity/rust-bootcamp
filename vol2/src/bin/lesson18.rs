#![recursion_limit = "1024"]

#[macro_use]
extern crate error_chain;
#[macro_use]
extern crate serde_derive;
extern crate serde_json;
extern crate tempfile;

use std::fmt;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::process::Command;

mod errors {
    error_chain!{}
}

use errors::*;

#[derive(Debug, Serialize, Deserialize)]
enum Frequency {
    Hourly(i32),
    Daily(i32),
    Monthly(i32),
}

#[derive(Debug, Serialize, Deserialize)]
struct Rule {
    frequency: Frequency,
    command: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct Schedule {
    rules: Vec<Rule>,
}

impl fmt::Display for Frequency {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Frequency::Hourly(minutes) => write!(f, "{} * * * *", minutes),
            Frequency::Daily(hour) => write!(f, "* {} * * *", hour),
            Frequency::Monthly(day) => write!(f, "* * {} * *", day),
        }
    }
}

impl fmt::Display for Rule {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} {}\n", self.frequency, self.command)
    }
}

impl fmt::Display for Schedule {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let _ = write!(f, "# Automatically generated by json2cron\n");
        for rule in &self.rules {
            let _ = write!(f, "{}", rule);
        }
        Ok(())
    }
}

fn main() {
    println!("24 Days of Rust, volume 2 - error_chain");
    if let Err(ref e) = run() {
        println!("error: {}", e);
        for e in e.iter().skip(1) {
            println!("caused by: {}", e);
        }
        if let Some(backtrace) = e.backtrace() {
            println!("backtrace: {:?}", backtrace);
        }
        std::process::exit(1);
    }
}

fn run() -> Result<()> {
    let schedule = load_schedule("data/schedule.json").chain_err(
        || "failed to load schedule",
    )?;
    if schedule.rules.is_empty() {
        bail!("the schedule is empty");
    }
    println!("{:#?}", schedule);
    println!("{}", schedule);
    update_crontab(&schedule).chain_err(|| "failed to update crontab")
}

fn load_schedule<P: AsRef<Path>>(path: P) -> Result<Schedule> {
    let file = File::open(path).chain_err(|| "failed to open input file")?;
    serde_json::from_reader(&file).chain_err(|| "failed to read JSON")
}

fn update_crontab(schedule: &Schedule) -> Result<()> {
    let mut file = tempfile::NamedTempFile::new().chain_err(
        || "failed to create a temporary file",
    )?;
    let schedule_str = format!("{}", schedule);
    file.write_all(&schedule_str.into_bytes()[..]).chain_err(
        || "failed to write schedule",
    )?;
    let path = file.path().to_str().ok_or("temporary path is not UTF-8")?;
    Command::new("crontab").arg(path).spawn().chain_err(
        || "failed to run crontab command",
    )?;
    Ok(())
}
